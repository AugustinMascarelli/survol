"""
	Transforms an internal graph into a HTML page.
"""

import sys
import lib_util
import lib_common
import lib_exports
import lib_patterns
import lib_naming
import lib_kbase
import entity_dirmenu_only
import lib_properties
from lib_properties import pc


# Needed because of sockets.
def WrtAsUtf(str):
	out_dest = lib_util.DfltOutDest()

	# TODO: try to make this faster. Should be conditional just like HttpHeader.
	out_dest.write( str.encode('utf-8') )


def WriteScriptInformation(topUrl,theCgi):
	"""
		This displays general information about this script and the object if there is one.
	"""
	sys.stderr.write("WriteScriptInformation entity_type=%s\n"%(theCgi.m_entity_type))

	# This is already called in lib_common, when creating CgiEnv.
	# It does not matter because this is very fast.
	callingUrl = lib_util.RequestUri()
	parsedEntityUri = lib_naming.ParseEntityUri(callingUrl,longDisplay=True)
	sys.stderr.write("parsedEntityUri=%s\n"%str(parsedEntityUri))
	#if parsedEntityUri[2]:
	#	# If there is an object to display.
	#	# Practically, we are in the script "entity.py" and the single doc string is "Overview"
	#	fullTitle = parsedEntityUri[0]
	#else:
	#	fullTitle = "NO TITLE"
	fullTitle = parsedEntityUri[0]
	WrtAsUtf('<h1>'+fullTitle+'</h1>')

	# This is the entire content, not only the first line.
	theDoc = lib_common.GetCallingModuleDoc()
	theDoc = theDoc.replace("\n","<br>")
	WrtAsUtf('<i><h2>%s</h2></i>'%(theDoc))

	if theCgi.m_entity_type:
		# WrtAsUtf('m_entity_id: %s<br>'%(theCgi.m_entity_id))

		WrtAsUtf('<table class="table_script_information">')

		entity_module = lib_util.GetEntityModule(theCgi.m_entity_type)
		entDoc = entity_module.__doc__
		if not entDoc:
			entDoc = ""
		# WrtAsUtf('Module class: %s: %s<br>'%(theCgi.m_entity_type,entDoc))

		WrtAsUtf(
		"""
		<tr>
			<td>%s</td>
			<td>%s</td>
		</tr>
		"""
		% ( theCgi.m_entity_type, entDoc ))

		for keyProp in theCgi.m_entity_id_dict:
			keyVal = theCgi.m_entity_id_dict[keyProp]

			WrtAsUtf(
			"""
			<tr>
				<td>%s</td>
				<td>%s</td>
			</tr>
			"""
			% ( keyProp, keyVal ))

		WrtAsUtf('</table>')



# TODO: Fix this.
def WriteParameters(parameters):
	"""
		This displays the parameters of the script and provide an URL to edit them.
	"""
	WrtAsUtf('<table class="table_script_parameters">')

	WrtAsUtf('<tr><td colspan="3"><a href="' + lib_exports.ModedUrl("edit") + '">CGI parameters edition</a></td></tr>')

	for keyParam,valParam in parameters.items():
		WrtAsUtf(
		"""
		<tr>
			<td>%s</td>
			<td colspan="2">%s</td>
		</tr>
		"""
		% ( keyParam, str(valParam) ))


	WrtAsUtf('</table>')

def WriteOtherUrls():
	"""
		This displays the URL to view the same document, in other ouput formats.
	"""

	WrtAsUtf('<table class="other_urls">')

	WrtAsUtf("""
	<tr>
		<td class="other_urls"><a href="%s">Content as SVG</a></td>
		<td>This displays the same content, in SVG format, generated by Graphviz</td>
	</tr>
	""" % lib_exports.ModedUrl("svg") )

	WrtAsUtf("""
	<tr>
		<td class="other_urls"><a href="%s">Content as RDF</a></td>
		<td>Same content, in RDF format, compatible with Semantic Web OWL standards, to be loaded by software such as Protege, etc...</td>
	</tr>
	""" % lib_exports.ModedUrl("rdf") )

	urlD3 = lib_exports.UrlToMergeD3()

	WrtAsUtf("""
	<tr>
		<td class="other_urls"><a href="%s">Content as D3</a></td>
		<td>Same content, displayed in Javascript D3 library</td>
	</tr>
	""" % urlD3 )

	WrtAsUtf('</table>')



def WriteScriptsTree(theCgi):
	"""
		This displays the tree of accessible Python scripts for the current object.
		It is dsiplayed as a recusive tab. A similar logic is used in entity.y
		(Where the tree is displayed as a tree of SVG nodes) and in index.htm
		(With a contextual menu).
	"""
	flagShowAll = False
	rootNode = None

	dictScripts = {}

	def CallbackGrphAdd( trpl, depthCall ):
		subj,prop,obj = trpl

		# sys.stderr.write("CallbackGrphAdd subj=%s\n"%str(subj))
		try:
			mapProps = dictScripts[subj]
			try:
				lstObjs = mapProps[prop].append(obj)
			except KeyError:
				mapProps[prop] = [obj]
		except KeyError:
			dictScripts[subj] = { prop : [obj ] }

	sys.stderr.write("WriteScriptsTree entity_type=%s\n"%(theCgi.m_entity_type))
	entity_dirmenu_only.DirToMenu(CallbackGrphAdd,rootNode,theCgi.m_entity_type,theCgi.m_entity_id,theCgi.m_entity_host,flagShowAll)

	sys.stderr.write("dictScripts %d\n"%len(dictScripts))


	def DisplayLevelTable(subj,depthMenu=1):
		"""
			Top-level should always be none.
			TODO: Have another version which formats all cells the same way.
			For this, have a first pass which counts, at each node, the number of sub-nodes.
			Then a second pass which uses thiese counts and the current depth,
			to calculate the rowspan and colspan of each cell.
			Although elegant, it is not garanteed to work.
		"""
		WrtAsUtf('<table class="table_scripts_titles">')
		try:
			mapProps = dictScripts[subj]
		except KeyError:
			return

		def ExtractTitleFromMapProps(mapProps):
			if len(mapProps) != 1:
				return None
			for oneProp in mapProps:
				if oneProp != pc.property_information:
					return None

				lstStr = mapProps[oneProp]
				if len(lstStr) != 1:
					return None
				retStr = lstStr[0]
				if lib_kbase.IsLink( retStr ):
					return None

				return str(retStr)

		WrtAsUtf('<tr>')
		depthMenu += 1

		subj_uniq_title = ExtractTitleFromMapProps(mapProps)

		if subj:
			subj_str = str(subj)
			WrtAsUtf("<td rowspan='%d'>"%len(mapProps))
			if lib_kbase.IsLink( subj ):
				url_with_mode = lib_util.ConcatenateCgi( subj_str, "mode=html" )
				WrtAsUtf( '<a href="' + url_with_mode + '">' + subj_uniq_title + "</a>")
			else:
				WrtAsUtf( subj_str )
			WrtAsUtf("</td>")

		if not subj_uniq_title:
			for oneProp in mapProps:
				lstObjs = mapProps[oneProp]

				WrtAsUtf('<td>')
				WrtAsUtf('<table class="table_scripts_links">')
				for oneObj in lstObjs:
					if oneObj is None:
						continue
					WrtAsUtf('<tr>')
					WrtAsUtf('<td>')
					try:
						mapPropsSub = dictScripts[oneObj]
						DisplayLevelTable(oneObj,depthMenu)
					except KeyError:
						WrtAsUtf("Script error: "+str(oneObj))
					WrtAsUtf('</td>')
					WrtAsUtf('</tr>')
				WrtAsUtf('</table>')
				WrtAsUtf('</td>')

		WrtAsUtf('</tr>')
		WrtAsUtf( "</table>")

	DisplayLevelTable(None)

	# TODO: Add this.
	#if entity_type != "":
	#	sys.stderr.write("Entering AddWbemWmiServers\n")
	#	CIM_ComputerSystem.AddWbemWmiServers(grph,rootNode, entity_host, nameSpace, entity_type, entity_id)

	#AddDefaultScripts(grph,rootNode,entity_host)

	# Special case if we are displaying a machine, we might as well try to connect to it.
	#if entity_type == "CIM_ComputerSystem":
	#	AddDefaultScripts(grph,rootNode,entity_id)


def WriteErrors(error_msg,isSubServer):
	if (error_msg != None) or isSubServer:
		# TODO: Use style-sheets.
		WrtAsUtf('<table border="0">')

		if error_msg != None:
			WrtAsUtf('<tr><td colspan="3" bgcolor="#DDDDDD"><b>' + error_msg + '</b></td></tr>')

		if isSubServer:
			WrtAsUtf('<tr><td colspan="3"><a href="' + lib_exports.ModedUrl("stop") + '">Stop subserver</a></td></tr>')
		WrtAsUtf( " </table><br>")


def WriteAllObjects(grph):
	"""
		This displays all the objects returend by this scripts.
		Other scripts are not here, so we do not have to eliminate them.
		This is therefore simpler than in the SVG (Graphviz) output,
		where all objects are mixed together.
	"""


	# This groups data by subject, then predicate, then object.
	dictClassSubjPropObj = dict()

	# TODO: Group objects by type, then display the count, some info about each type etc...
	for aSubj, aPred, anObj in grph:
		# No point displaying some keys if there is no value.
		if aPred == pc.property_information :
			if str(anObj) == "":
				continue

		subj_str = str(aSubj)
		( subj_title, entity_graphic_class, entity_id ) = lib_naming.ParseEntityUri(subj_str)

		try:
			dictSubjPropObj = dictClassSubjPropObj[entity_graphic_class]
			try:
				dictPred = dictSubjPropObj[aSubj]
				try:
					dictPred[aPred].append(anObj)
				except KeyError:
					# First time this object has this predicate.
					dictPred[aPred] = [ anObj ]
			except KeyError:
				# First time we see this object.
				dictSubjPropObj[aSubj] = { aPred : [ anObj ] }
		except KeyError:
			# First object of this class.
			dictClassSubjPropObj[entity_graphic_class] = { aSubj: { aPred : [ anObj ] } }

	# Group objects by class.
	# Display list of classes with an indexs and a link to the class.
	# "NO TITLE" is wrong
	# Trier par le nom.

	# Ajouter mode "difference": On recalcule periodiquement et on affiche la difference.


	for entity_graphic_class in dictClassSubjPropObj:
		WrtAsUtf("<h3/>Class %s<h2/>"%entity_graphic_class)
		dictSubjPropObj = dictClassSubjPropObj[entity_graphic_class]

		DispClassObjects(dictSubjPropObj)

def DispClassObjects(dictSubjPropObj):
	listPropsTdDoubleColSpan = [pc.property_information,pc.property_rdf_data_nolist2,pc.property_rdf_data_nolist1]

	WrtAsUtf('<table class="class_objects">')
	for aSubj in dictSubjPropObj:
		dictPred = dictSubjPropObj[aSubj]

		subj_str = str(aSubj)
		( subj_title, entity_graphic_class, entity_id ) = lib_naming.ParseEntityUri(subj_str)

		arrayGraphParams = lib_patterns.TypeToGraphParams(entity_graphic_class)
		# "Graphic_shape","Graphic_colorfill","Graphic_colorbg","Graphic_border","Graphic_is_rounded"
		colorClass = arrayGraphParams[1]


		# Total number of lines.
		cntPreds = 0
		for aPred in dictPred:
			lstObjs = dictPred[aPred]
			cntPreds += len(lstObjs)

		mustWriteColOneSubj = True

		# TODO: The second sort key should be the value.
		for aPred in sorted(dictPred):
			lstObjs = dictPred[aPred]

			predStr = lib_exports.AntiPredicateUri(str(aPred))
			cntObjs = len(lstObjs)
			mustWriteColOnePred = True

			for anObj in lstObjs:

				WrtAsUtf( '<tr bgcolor="' + colorClass + '">' )

				if mustWriteColOneSubj:
					WrtAsUtf(
						'<td rowspan="' + str(cntPreds) + '">'
						+'<a href="' + subj_str + '">'+ subj_title + "</a>"
						# + " (" + entity_graphic_class + ")"
						+ "</td>")
					mustWriteColOneSubj = False

				if mustWriteColOnePred:
					# if aPred != pc.property_information :
					if aPred not in listPropsTdDoubleColSpan :
						WrtAsUtf( '<td rowspan="' + str(cntObjs) + '">'+ predStr + "</td>")
					mustWriteColOnePred = False

				obj_str = str(anObj)

				if aPred in listPropsTdDoubleColSpan:
					colSpan = 2
				else:
					colSpan = 1

				if lib_kbase.IsLink( anObj ):
					obj_title = lib_naming.ParseEntityUri(obj_str)[0]
					url_with_mode = lib_util.ConcatenateCgi( obj_str, "mode=html" )
					WrtAsUtf( '<td colSpan="%d"><a href="%s">%s</a></td>' % (colSpan,url_with_mode,obj_title))
				else:
					WrtAsUtf( '<td colspan="%d">%s</td>' %(colSpan,obj_str))

				WrtAsUtf( "</tr>")

	WrtAsUtf( " </table>")

def Grph2Html( theCgi, topUrl, error_msg, isSubServer):
	"""
		This transforms an internal data graph into a HTML document.
	"""
	page_title = theCgi.m_page_title
	grph = theCgi.m_graph
	parameters = theCgi.m_parameters

	lib_util.WrtHeader('text/html')
	WrtAsUtf( "<head>" )

	# TODO: Encode HTML special characters.
	WrtAsUtf( "<title>" + page_title + "</title>")

	# The href must be absolute so it will work with any script.
	# However we must calculate its prefix.
	WrtAsUtf(
		"""
		<link rel='stylesheet' type='text/css' href='/survol/www/css/html_exports.css'>
		""")

	WrtAsUtf('</head>')

	WrtAsUtf('<body>')

	WriteScriptInformation(topUrl,theCgi)

	WriteErrors(error_msg,isSubServer)

	WrtAsUtf("<h2/>Objects<h2/>")
	WriteAllObjects(grph)

	WrtAsUtf("<h2/>Related scripts<h2/>")
	WriteScriptsTree(theCgi)

	WrtAsUtf("<h2/>Script parameters<h2/>")
	WriteParameters(parameters)

	WrtAsUtf("<h2/>Other urls related to this object<h2/>")
	WriteOtherUrls()

	WrtAsUtf("</body>")

	WrtAsUtf("</html> ")

################################################################################
